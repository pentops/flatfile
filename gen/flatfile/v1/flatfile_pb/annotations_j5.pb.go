// Code generated by protoc-gen-go-j5. DO NOT EDIT.

package flatfile_pb

import (
	driver "database/sql/driver"
	fmt "fmt"

	j5reflect "github.com/pentops/j5/lib/j5reflect"
	proto "google.golang.org/protobuf/proto"
)

func (msg *Message) Clone() any {
	return proto.Clone(msg).(*Message)
}
func (msg *Message) J5Reflect() j5reflect.Root {
	return j5reflect.MustReflect(msg.ProtoReflect())
}

func (msg *Message) J5Object() j5reflect.Object {
	return j5reflect.MustReflect(msg.ProtoReflect()).(j5reflect.Object)
}

func (msg *FixedWidth) Clone() any {
	return proto.Clone(msg).(*FixedWidth)
}
func (msg *FixedWidth) J5Reflect() j5reflect.Root {
	return j5reflect.MustReflect(msg.ProtoReflect())
}

func (msg *FixedWidth) J5Object() j5reflect.Object {
	return j5reflect.MustReflect(msg.ProtoReflect()).(j5reflect.Object)
}

func (msg *Field) Clone() any {
	return proto.Clone(msg).(*Field)
}

type IsField_FieldType = isField_FieldType

func (msg *Field) J5Reflect() j5reflect.Root {
	return j5reflect.MustReflect(msg.ProtoReflect())
}

func (msg *Field) J5Object() j5reflect.Object {
	return j5reflect.MustReflect(msg.ProtoReflect()).(j5reflect.Object)
}

func (msg *StringField) Clone() any {
	return proto.Clone(msg).(*StringField)
}
func (msg *StringField) J5Reflect() j5reflect.Root {
	return j5reflect.MustReflect(msg.ProtoReflect())
}

func (msg *StringField) J5Object() j5reflect.Object {
	return j5reflect.MustReflect(msg.ProtoReflect()).(j5reflect.Object)
}

func (msg *BoolField) Clone() any {
	return proto.Clone(msg).(*BoolField)
}
func (msg *BoolField) J5Reflect() j5reflect.Root {
	return j5reflect.MustReflect(msg.ProtoReflect())
}

func (msg *BoolField) J5Object() j5reflect.Object {
	return j5reflect.MustReflect(msg.ProtoReflect()).(j5reflect.Object)
}

func (msg *NumberField) Clone() any {
	return proto.Clone(msg).(*NumberField)
}
func (msg *NumberField) J5Reflect() j5reflect.Root {
	return j5reflect.MustReflect(msg.ProtoReflect())
}

func (msg *NumberField) J5Object() j5reflect.Object {
	return j5reflect.MustReflect(msg.ProtoReflect()).(j5reflect.Object)
}

func (msg *Enum) Clone() any {
	return proto.Clone(msg).(*Enum)
}
func (msg *Enum) J5Reflect() j5reflect.Root {
	return j5reflect.MustReflect(msg.ProtoReflect())
}

func (msg *Enum) J5Object() j5reflect.Object {
	return j5reflect.MustReflect(msg.ProtoReflect()).(j5reflect.Object)
}

func (msg *DateField) Clone() any {
	return proto.Clone(msg).(*DateField)
}
func (msg *DateField) J5Reflect() j5reflect.Root {
	return j5reflect.MustReflect(msg.ProtoReflect())
}

func (msg *DateField) J5Object() j5reflect.Object {
	return j5reflect.MustReflect(msg.ProtoReflect()).(j5reflect.Object)
}

// Trim
const (
	Trim_UNSPECIFIED Trim = 0
	Trim_LEFT        Trim = 1
	Trim_RIGHT       Trim = 2
	Trim_BOTH        Trim = 3
)

var (
	Trim_name_short = map[int32]string{
		0: "UNSPECIFIED",
		1: "LEFT",
		2: "RIGHT",
		3: "BOTH",
	}
	Trim_value_short = map[string]int32{
		"UNSPECIFIED": 0,
		"LEFT":        1,
		"RIGHT":       2,
		"BOTH":        3,
	}
	Trim_value_either = map[string]int32{
		"UNSPECIFIED":      0,
		"TRIM_UNSPECIFIED": 0,
		"LEFT":             1,
		"TRIM_LEFT":        1,
		"RIGHT":            2,
		"TRIM_RIGHT":       2,
		"BOTH":             3,
		"TRIM_BOTH":        3,
	}
)

// ShortString returns the un-prefixed string representation of the enum value
func (x Trim) ShortString() string {
	return Trim_name_short[int32(x)]
}
func (x Trim) Value() (driver.Value, error) {
	return []uint8(x.ShortString()), nil
}
func (x *Trim) Scan(value interface{}) error {
	var strVal string
	switch vt := value.(type) {
	case []uint8:
		strVal = string(vt)
	case string:
		strVal = vt
	default:
		return fmt.Errorf("invalid type %T", value)
	}
	val := Trim_value_either[strVal]
	*x = Trim(val)
	return nil
}

// MissingIs
const (
	MissingIs_UNSPECIFIED MissingIs = 0
	MissingIs_ERROR       MissingIs = 1
	MissingIs_TRUE        MissingIs = 2
	MissingIs_FALSE       MissingIs = 3
)

var (
	MissingIs_name_short = map[int32]string{
		0: "UNSPECIFIED",
		1: "ERROR",
		2: "TRUE",
		3: "FALSE",
	}
	MissingIs_value_short = map[string]int32{
		"UNSPECIFIED": 0,
		"ERROR":       1,
		"TRUE":        2,
		"FALSE":       3,
	}
	MissingIs_value_either = map[string]int32{
		"UNSPECIFIED":            0,
		"MISSING_IS_UNSPECIFIED": 0,
		"ERROR":                  1,
		"MISSING_IS_ERROR":       1,
		"TRUE":                   2,
		"MISSING_IS_TRUE":        2,
		"FALSE":                  3,
		"MISSING_IS_FALSE":       3,
	}
)

// ShortString returns the un-prefixed string representation of the enum value
func (x MissingIs) ShortString() string {
	return MissingIs_name_short[int32(x)]
}
func (x MissingIs) Value() (driver.Value, error) {
	return []uint8(x.ShortString()), nil
}
func (x *MissingIs) Scan(value interface{}) error {
	var strVal string
	switch vt := value.(type) {
	case []uint8:
		strVal = string(vt)
	case string:
		strVal = vt
	default:
		return fmt.Errorf("invalid type %T", value)
	}
	val := MissingIs_value_either[strVal]
	*x = MissingIs(val)
	return nil
}

// Encoding
const (
	Encoding_UNSPECIFIED    Encoding = 0
	Encoding_PACKED_DECIMAL Encoding = 1
	Encoding_OVERPUNCH      Encoding = 2
	Encoding_BINARY         Encoding = 3
)

var (
	Encoding_name_short = map[int32]string{
		0: "UNSPECIFIED",
		1: "PACKED_DECIMAL",
		2: "OVERPUNCH",
		3: "BINARY",
	}
	Encoding_value_short = map[string]int32{
		"UNSPECIFIED":    0,
		"PACKED_DECIMAL": 1,
		"OVERPUNCH":      2,
		"BINARY":         3,
	}
	Encoding_value_either = map[string]int32{
		"UNSPECIFIED":             0,
		"ENCODING_UNSPECIFIED":    0,
		"PACKED_DECIMAL":          1,
		"ENCODING_PACKED_DECIMAL": 1,
		"OVERPUNCH":               2,
		"ENCODING_OVERPUNCH":      2,
		"BINARY":                  3,
		"ENCODING_BINARY":         3,
	}
)

// ShortString returns the un-prefixed string representation of the enum value
func (x Encoding) ShortString() string {
	return Encoding_name_short[int32(x)]
}
func (x Encoding) Value() (driver.Value, error) {
	return []uint8(x.ShortString()), nil
}
func (x *Encoding) Scan(value interface{}) error {
	var strVal string
	switch vt := value.(type) {
	case []uint8:
		strVal = string(vt)
	case string:
		strVal = vt
	default:
		return fmt.Errorf("invalid type %T", value)
	}
	val := Encoding_value_either[strVal]
	*x = Encoding(val)
	return nil
}
